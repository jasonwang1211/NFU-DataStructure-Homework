# 41143109

作業一

## 解題說明

### 問題一：Ackermann 函式
Ackermann 函式是著名的 非原始遞迴（non‑primitive‑recursive）函式，其數學定義為
```
A(m, n) = {
    n + 1                     , m = 0
    A(m‑1, 1)                 , m > 0 且 n = 0
    A(m‑1, A(m, n‑1))         , m > 0 且 n > 0
}

```
- 特性:由於增長速度極快，只接受小範圍測試（如 m≤3、n≤4）才不會因堆疊或記憶體耗盡而失敗。
- 本作業要求:
1. 實作 遞迴版（直接對照數學定義）。
2. 實作 迭代版，以手寫 堆疊 模擬遞迴，避免系統呼叫堆疊的深度限制。

### 解題策略

1. 遞迴實作:直接映射定義，最簡潔的解法。
2. 迭代實作（手寫堆疊）:避免系統呼叫堆疊深度限制，讓程式自行管理深度。

## 程式實作

以下為主要程式碼：
1. 遞迴版
```cpp
#include <iostream>
using namespace std;

   
long long ackermannRec(int m, int n)
{
    if (m == 0) return n + 1;
    if (n == 0) return ackermannRec(m - 1, 1);
    return ackermannRec(m - 1,
        ackermannRec(m, n - 1));
}
```
2. 迭代版 – 手寫堆疊模擬遞迴
```cpp
#include <iostream>
using namespace std;


long long ackermannItr(int m, int n)
{
    const int MAX_STK = 100000;         
    int *stk = new int[MAX_STK];        
    int top = -1;                        

    while (true)
    {
        if (m == 0)                      // 基本情形 A(0,n) = n+1
        {
            n = n + 1;
            if (top < 0) break;          
            m = stk[top--];              // 彈回上一層的 m
        }
        else if (n == 0)                 // A(m,0) = A(m-1,1)
        {
            n = 1;
            m = m - 1;
        }
        else                             // A(m,n) = A(m-1, A(m,n-1))
        {
            stk[++top] = m - 1;           // 把外層的 m-1 暫存
            n = n - 1;                    // 先算內層 A(m,n-1)
            // m 保持不變，下一輪迴圈會再次判斷
        }
    }

    delete[] stk;
    return n;                            // 最終的 n 即 A(m0,n0)
}

```
## 效能分析


時間複雜度:當 m = 0 時， $O(1)$ 。  
當 m = 1 時， $O(n)$ 。  
當 m = 2 時，  $O(2n + 3)$ 。  
當 m = 3 時， $O(2^{n+3})$ 。  
當 m = 4 時， $O(2^{2^{n}})$ 。  
這正是 Ackermann 的遞迴定義。每一次展開都會產生 一個 直接的遞迴呼叫與 一個 內層的 A(m,n‑1)。
因此遞迴樹的節點數 恰好等於 A(m,n) 本身的值（每個節點代表一次基本的 +1 操作）。
因此整體時間複雜度可表為 $T(m,n)$ = $O( A(m,n) )$    

空間複雜度:遞迴版空間複雜度為  $O(m + n)$ 。非遞迴版空間複雜度為 $O(m + n)$ 。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $n = 0$      | 0        | 0        |
| 測試二   | $n = 1$      | 1        | 1        |
| 測試三   | $n = 3$      | 6        | 6        |
| 測試四   | $n = 5$      | 15       | 15       |
| 測試五   | $n = -1$     | 異常拋出 | 異常拋出 |

### 編譯與執行指令

```shell
$ g++ -std=c++17 -o sigma sigma.cpp
$ ./sigma
6
```

### 結論

1. 程式能正確計算 $n$ 到 $1$ 的連加總和。  
2. 在 $n < 0$ 的情況下，程式會成功拋出異常，符合設計預期。  
3. 測試案例涵蓋了多種邊界情況（$n = 0$、$n = 1$、$n > 1$、$n < 0$），驗證程式的正確性。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

1. **程式邏輯簡單直觀**  
   遞迴的寫法能夠清楚表達「將問題拆解為更小的子問題」的核心概念。  
   例如，計算 $\Sigma(n)$ 的過程可分解為：  

   $$
   \Sigma(n) = n + \Sigma(n-1)
   $$

   當 $n$ 等於 1 或 0 時，直接返回結果，結束遞迴。

2. **易於理解與實現**  
   遞迴的程式碼更接近數學公式的表示方式，特別適合新手學習遞迴的基本概念。  
   以本程式為例：  

   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

3. **遞迴的語意清楚**  
   在程式中，每次遞迴呼叫都代表一個「子問題的解」，而最終遞迴的返回結果會逐層相加，完成整體問題的求解。  
   這種設計簡化了邏輯，不需要額外變數來維護中間狀態。

透過遞迴實作 Sigma 計算，程式邏輯簡單且易於理解，特別適合展示遞迴的核心思想。然而，遞迴會因堆疊深度受到限制，當 $n$ 值過大時，應考慮使用迭代版本來避免 Stack Overflow 問題。
